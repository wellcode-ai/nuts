use crate::collections::*;  // Import all types from collections
use crate::commands::perf::PerfCommand;
use rustyline::Editor;
use std::path::PathBuf;
use std::fs;
use std::time::Duration;
use std::collections::HashMap;
use url::Url;
use serde::{Serialize, Deserialize};
use std::path::Path;
use crate::collections::docs_generator::DocsGenerator;
use crate::config::Config;

pub struct CollectionManager {
    collections_dir: PathBuf,
    config: Config,
}

impl CollectionManager {
    pub fn new() -> Self {
        // Create collections directory if it doesn't exist
        let collections_dir = dirs::home_dir()
            .map(|h| h.join(".nuts").join("collections"))
            .expect("Could not determine home directory");
            
        std::fs::create_dir_all(&collections_dir)
            .expect("Failed to create collections directory");
            
        Self {
            collections_dir: collections_dir,
            config: Config::new(),
        }
    }

    fn get_collection_path(&self, name: &str) -> PathBuf {
        let mut path = self.collections_dir.clone();
        path.push(format!("{}.yaml", name));
        path
    }

    pub fn create_collection(&self, name: &str) -> Result<(), Box<dyn std::error::Error>> {
        let path = self.get_collection_path(name);
        
        let template = OpenAPISpec::new(&name);
        
        template.save(path)?;
        println!("âœ… Created collection: {}", name);
        Ok(())
    }

    pub async fn run_collection(&self, _name: &str) -> Result<(), Box<dyn std::error::Error>> {
        println!("Not implemented yet");
        Ok(())
    }

    pub async fn start_mock_server(&self, _name: &str) -> Result<(), Box<dyn std::error::Error>> {
        println!("Not implemented yet");
        Ok(())
    }

    pub fn save_request_to_collection(
        &self,
        collection_name: &str,
        endpoint_name: &str,
        request: &(String, String, Option<String>)
    ) -> Result<(), Box<dyn std::error::Error>> {
        let (method, url, body) = request;
        let path = self.get_collection_path(collection_name);
        
        let mut spec = if path.exists() {
            OpenAPISpec::load(path.clone())?
        } else {
            OpenAPISpec::new(collection_name)
        };

        // Parse URL to get path and server
        let url_parsed = Url::parse(url)?;
        let server_url = format!("{}://{}", url_parsed.scheme(), url_parsed.host_str().unwrap_or(""));
        let path_str = url_parsed.path().to_string();

        // Update servers if needed
        if !spec.servers.iter().any(|s| s.url == server_url) {
            spec.servers.push(Server {
                url: server_url,
                description: Some("Added by NUTS".to_string()),
            });
        }

        // Create operation
        let operation = Operation {
            summary: Some(endpoint_name.to_string()),
            description: Some(format!("Generated by NUTS from {} request", method)),
            parameters: None,
            requestBody: if let Some(body_str) = body {
                Some(RequestBody {
                    description: Some("Request body".to_string()),
                    required: Some(true),
                    content: {
                        let mut content = HashMap::new();
                        content.insert("application/json".to_string(), MediaType {
                            schema: self.infer_schema_from_json(body_str)?,
                            example: Some(serde_json::from_str(body_str)?),
                        });
                        content
                    },
                })
            } else {
                None
            },
            responses: {
                let mut responses = HashMap::new();
                responses.insert("200".to_string(), Response {
                    description: "Successful response".to_string(),
                    content: None,
                });
                responses
            },
            security: None,
            tags: Some(vec![endpoint_name.to_string()]),
        };

        // Add path
        let path_item = spec.paths.entry(path_str).or_insert(PathItem {
            get: None,
            post: None,
            put: None,
            delete: None,
            patch: None,
            mock_data: None,
        });

        // Update operation based on method
        match method.to_uppercase().as_str() {
            "GET" => path_item.get = Some(operation),
            "POST" => path_item.post = Some(operation),
            "PUT" => path_item.put = Some(operation),
            "DELETE" => path_item.delete = Some(operation),
            "PATCH" => path_item.patch = Some(operation),
            _ => return Err("Unsupported HTTP method".into()),
        }

        // Save the updated spec
        spec.save(path)?;
        println!("âœ… Saved endpoint '{}' to OpenAPI collection '{}'", endpoint_name, collection_name);
        
        Ok(())
    }

    fn infer_schema_from_json(&self, json_str: &str) -> Result<Schema, Box<dyn std::error::Error>> {
        let value: serde_json::Value = serde_json::from_str(json_str)?;
        Ok(match value {
            serde_json::Value::Object(map) => {
                let mut properties = HashMap::new();
                for (key, value) in map {
                    properties.insert(key, self.infer_schema_from_value(&value));
                }
                Schema {
                    schema_type: "string".to_string(),
                    format: None,
                    properties: Some(properties),
                    items: None,
                }
            },
            _ => self.infer_schema_from_value(&value),
        })
    }

    fn infer_schema_from_value(&self, value: &serde_json::Value) -> Schema {
        match value {
            serde_json::Value::String(_) => Schema {
                schema_type: "string".to_string(),
                format: None,
                properties: None,
                items: None,
            },
            serde_json::Value::Number(n) => Schema {
                schema_type: if n.is_i64() { "integer" } else { "number" }.to_string(),
                format: None,
                properties: None,
                items: None,
            },
            serde_json::Value::Bool(_) => Schema {
                schema_type: "boolean".to_string(),
                format: None,
                properties: None,
                items: None,
            },
            serde_json::Value::Array(arr) => Schema {
                schema_type: "array".to_string(),
                format: None,
                properties: None,
                items: Some(Box::new(if let Some(first) = arr.first() {
                    self.infer_schema_from_value(first)
                } else {
                    Schema {
                        schema_type: "string".to_string(),
                        format: None,
                        properties: None,
                        items: None,
                    }
                })),
            },
            serde_json::Value::Null => Schema {
                schema_type: "string".to_string(),
                format: None,
                properties: None,
                items: None,
            },
            _ => Schema {
                schema_type: "string".to_string(),
                format: None,
                properties: None,
                items: None,
            },
        }
    }

    pub async fn configure_mock_data(
        &self,
        collection: &str,
        endpoint: &str,
        editor: &mut Editor<impl rustyline::Helper, impl rustyline::history::History>
    ) -> Result<(), Box<dyn std::error::Error>> {
        println!("Configuring mock data generation for {}/{}", collection, endpoint);
        
        let description = editor.readline("Enter data description: ")?;
        let schema = editor.readline("Enter JSON schema (optional): ")?;
        let example = editor.readline("Enter example (optional): ")?;

        let mock_config = MockDataConfig {
            description,
            schema: if schema.is_empty() { None } else { Some(schema) },
            examples: if example.is_empty() { None } else { Some(vec![example]) },
        };

        let path = self.get_collection_path(collection);
        let mut collection = OpenAPISpec::load(path.clone())?;
        
        if let Some((path_str, item)) = collection.paths.iter_mut().find(|(path, _)| path.contains(endpoint)) {
            item.mock_data = Some(mock_config);
            collection.save(path)?;
            println!("âœ… Mock data configuration saved");
        }

        Ok(())
    }

    pub async fn run_collection_perf(
        &self,
        name: &str,
        args: &[String]
    ) -> Result<(), Box<dyn std::error::Error>> {
        let path = self.get_collection_path(name);
        let collection = OpenAPISpec::load(path)?;
        println!("ðŸš€ Running performance tests for collection: {}", collection.info.title);

        // Parse common arguments
        let users = args.iter()
            .position(|x| x == "--users")
            .and_then(|i| args.get(i + 1))
            .and_then(|u| u.parse().ok())
            .unwrap_or(10);
            
        let duration = args.iter()
            .position(|x| x == "--duration")
            .and_then(|i| args.get(i + 1))
            .and_then(|d| d.trim_end_matches('s').parse().ok())
            .map(|secs| Duration::from_secs(secs))
            .unwrap_or(Duration::from_secs(30));

        for (path_str, item) in collection.paths {
            let full_url = if path_str.starts_with("http") {
                path_str
            } else {
                format!("{}{}", collection.servers[0].url, path_str)
            };

            let method = if item.get.is_some() { "GET" }
                else if item.post.is_some() { "POST" }
                else if item.put.is_some() { "PUT" }
                else if item.delete.is_some() { "DELETE" }
                else if item.patch.is_some() { "PATCH" }
                else { return Err("No HTTP method defined for path".into()) };

            let operation = if item.get.is_some() { &item.get }
                else if item.post.is_some() { &item.post }
                else if item.put.is_some() { &item.put }
                else if item.delete.is_some() { &item.delete }
                else if item.patch.is_some() { &item.patch }
                else { return Err("No HTTP method defined for path".into()) };

            PerfCommand::new().run(
                &full_url,
                users,
                duration,
                method,
                operation
                    .as_ref()
                    .and_then(|op| op.requestBody.as_ref())
                    .and_then(|body| body.content.get("application/json"))
                    .and_then(|media| media.example.as_ref())
                    .map(|ex| ex.to_string())
                    .as_deref()
            ).await?;
        }
        
        Ok(())
    }

    pub async fn generate_docs(&self, name: &str) -> Result<(), Box<dyn std::error::Error>> {
        let path = self.get_collection_path(name);
        println!("Looking for collection at: {:?}", path);
        
        println!("Directory contents:");
        if let Ok(entries) = std::fs::read_dir(&self.collections_dir) {
            for entry in entries {
                if let Ok(entry) = entry {
                    println!("  {:?}", entry.path());
                }
            }
        }
        
        if !path.exists() {
            println!("File does not exist at: {:?}", path);
            return Err("Collection file not found".into());
        }
        
        match std::fs::read_to_string(&path) {
            Ok(content) => {
                println!("File content length: {} bytes", content.len());
                println!("File content preview: {}", &content[..content.len().min(100)]);
                
                match serde_yaml::from_str::<OpenAPISpec>(&content) {
                    Ok(spec) => {
                        let api_key = self.config.get_anthropic_key()?;
                        let docs_generator = DocsGenerator::new(&api_key);
                        let output_dir = Path::new("docs").join(name);
                        
                        // Create docs directory if it doesn't exist
                        std::fs::create_dir_all(&output_dir)?;
                        println!("Created output directory at: {:?}", output_dir);
                        
                        docs_generator.generate(&spec, &output_dir).await?;
                        Ok(())
                    },
                    Err(e) => {
                        println!("Failed to parse YAML: {}", e);
                        Err(e.into())
                    }
                }
            },
            Err(e) => {
                println!("Error reading file: {}", e);
                Err(e.into())
            }
        }
    }
}

impl OpenAPISpec {
    pub fn load(path: PathBuf) -> Result<Self, Box<dyn std::error::Error>> {
        let contents = fs::read_to_string(path)?;
        let spec = serde_yaml::from_str(&contents)?;
        Ok(spec)
    }

    pub fn save(&self, path: PathBuf) -> Result<(), Box<dyn std::error::Error>> {
        let yaml = serde_yaml::to_string(&self)?;
        fs::write(path, yaml)?;
        Ok(())
    }
}
